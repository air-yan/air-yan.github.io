
**生成学习算法**

**页面导航**

-   ***1 判别模型***

-   ***2 生成模型***

-   ***3 高斯判别分析***

    -   *3.1 多元正态分布*

<!-- -->

-   ***4 高斯判别分析和逻辑回归***

    -   *4.1 高斯判别分析*

    -   *4.2 高斯判别分析和逻辑回归*

-   ***5 朴素贝叶斯***

-   ***6 拉普拉斯平滑处理***

**1 判别模型**

判别模型是一种对观测数据进行直接分类的模型，常见的模型有逻辑回归和感知机学习算法等。此模型仅对数据进行分类，并不能具象化或者量化数据本身的分布状态，因此也无法根据分类生成可观测的图像。

定义上，判别模型通过构建条件概率分布p(y|x;θ)预测y，即在特征x出现的情况下标记y出现的概率。此处p可以是逻辑回归模型。

**2生成模型**

与判别模型不同，生成模型首先了解数据本身分布情况，并进一步根据输入x，给出预测分类y的概率。该模型有着研究数据分布形态的概念，可以根据历史数据生成新的可观测图像。

贝叶斯分类就是一个典型的例子。在这个例子中，我们有一个先验分类，根据这个先验分类，我们可以使用贝叶斯原理计算每个分类的概率，然后取概率最高的概率。同时，我们还可以根据特定的先验生成特征。这就是一个生成过程。

**3 高斯判别分析**

高斯判别分析（GDA）是一个生成模型，其中p(x|y)是多元高斯正态分布。

**3.1 多元高斯正态分布**

在多元正态分布中，一个随机变量是一个在维度为n的R<sub>n</sub>空间中的矢量值。因此，多元高斯的均值向量 μ∈R<sub>n</sub>，协方差矩阵Σ∈R<sub>n x n</sub> ，其中$ \\ Sigma是对称的半正定矩阵。其概率密度函数为：

![](media/image1.png)

如上所述，μ是期望值。

向量值随机变量Z的协方差为：

![](media/image2.png)

下图显示了均值为零但不同协方差的几个密度函数。

![](media/image3.png)

以下为上图的协方差（从左到右）：

![](media/image4.png)

**4 高斯判别分析和逻辑回归**

**4.1 高斯判别分析**

我们再来谈谈二元分类的问题，我们可以用多元高斯模型对p(x|y)进行建模。 总的来讲，我们有：

![](media/image5.png)

其中φ，μ<sub>0</sub>，μ<sub>1</sub>，Σ是我们想要找出的参数。 请注意，虽然我们对不同的类有不同的均值，但我们在不同的类之间有着共享的协方差。

为什么它是一个生成模型？简而言之，我们有一个类的先验概率，这个类是伯努利分布。生成过程是（1）从伯努利分布中抽样。 （2）基于类标签，我们从相应的分布中抽取x。

所以，该数据的对数似然函数值是：

![](media/image6.png)

在上面的等式中，我们插入各个分布而不指明任何类，我们仅将它们抽象为k。所以我们有：

![](media/image7.png)

现在，我们需要对每个参数进行取导，然后将它们设为零找到 argmax（函数值最大时对应的输入值x）。 一些可能对推导有用的公式列举如下：

![](media/image8.png)（如果A是对称的并且与x相互独立）

![](media/image9.png)

-----------------

**证明：**
矩阵A是对称矩阵，所以 *A*= *A*<sup>T</sup>并假设空间维度为n。

![](media/image10.png)

雅可比公式：

![](media/image11.png)

**证明：**

![](media/image12.png)

**证明：**

这个证明有些复杂。你应该事先了解克罗内克函数和Frobenius内部乘积。对于矩阵X，我们可以写成：

![](media/image13.png)

你可以将H视为Frobenius内积的标识元素。在开始证明之前，让我们准备好去找逆矩阵的导数。也就是说，∂X<sup>-1</sup>/∂X。

![](media/image14.png)

所以我们可以这么解：

![](media/image15.png)

接着，让我们回到正题：

![](media/image16.png)

其中F表示Frobenius内积。

接着，带回到原始公式：

![](media/image17.png)

现在，我们已经有足够的准备去找到每个参数的梯度了。

-----------------

对ϕ取导并设为0：

![](media/image18.png)

对 μk取导并设为0：

![](media/image19.png)

对 Σ 取导并设为0:

![](media/image20.png)

结果如图所示：

![](media/image21.png)

请注意，由于有着共享协方差，因此上图两个轮廓的形状是相同的，但均值则不同。 在边界线上（自左上到右下的直线），每个类的概率为50%。

**4.2 高斯判别分析（GDA）和逻辑回归**

高斯判别分析是如何与逻辑回归相关联的呢？我们可以发现如果上述p(x|y) 是具有共享协方差的多元高斯，我们就可以计算p(x|y)然后发现它是遵循逻辑函数的。要证明这一点，我们可以：

![](media/image22.png)

由于高斯属于指数族，我们最终可以将分母中的比率转换为exp（θ<sup>T</sup>x），其中 θ 是φ，μ<sub>0</sub>，μ<sub>1</sub>，Σ的函数。

同样的，如果p(x|y) 是具有不同 λ 的泊松分布，则p(x|y) 也遵循逻辑函数。 这意味着GDA模型本身有一个强假设，即每个类的数据都可以用具有共享协方差的高斯模型建模。但是，如果这个假设是正确的话，GDA将可以更好并且更快地训练模型。

另一方面，如果不能做出假设，逻辑回归就不那么敏感了。因此，你可以直接使用逻辑回归，而无需接触高斯假设或Possion假设。

**5 朴素贝叶斯**

在高斯判别分析中，随机变量应使用具有连续值特征的数据。 而朴素贝叶斯则用于学习离散值随机变量，如文本分类。在文本分类中，模型基于文本中的单词将文本标记为二进制类，单词被向量化并用于模型训练。一个单词向量就像一本字典一样，其长度是字典中单词储存的数量，其二进度值则代表着是否为某个词。 一个单词在单词向量中由1表示“是”，而单词向量中的其他位置则是0。

然而，这可能并不起作用。 比方说，如果我们有50,000个单词并尝试将其建模为多项式，则参数的维数为250,000-1,250,000-1，这太大了。 因此，为了解决这个问题，我们做出了

**朴素贝叶斯假设**：

基于给定分类下，每个词彼此间条件独立。

于是，我们有：![](media/image23.png)

我们对第一步应用**概率论中的链式法则**，对第二步应用朴素贝叶斯假设。

找到对数似然函数值的最大值：

![](media/image24.png)

其中 ϕ<sub>j|y=1</sub> = P (x<sub>j</sub>=1|y=1)，ϕ <sub>j|y=1</sub> = P(x<sub>j</sub>=1|y=1), ϕ<sub>j|y=0</sub> = P(x<sub>j</sub>=1|y=0) 并且 ϕ<sub>y</sub>= p(y=1)。 这些是我们需要训练的参数。

我们可以对其求导:

![](media/image25.png)

为了预测新样本，我们可以使用**贝叶斯法则**来计算P（y = 1 | x）并比较哪个更高。![](media/image26.png)

**延伸**: 在这种情况下，因为y是二进制值（0，1），我们将P（x<sub>i</sub> | y）建模为伯努利分布。 也就是说，它可以是“有那个词”或“没有那个词”。 伯努利将类标签作为输入并对其概率进行建模，前提是它必须是二进制的。 如果是处理非二进制值X<sub>i</sub>，我们可以将其建模为多项式分布，多项式分布可以对多个类进行参数化。

**总结**: 朴素贝叶斯适用于离散空间，高斯判别分析适用于连续空间。我们任何时候都能将其离散化。

**6 拉普拉斯平滑处理**

上面的示例通常是好的，不过当新邮件中出现过去训练样本中不存在的单词时，该模型将会预测失败。 在这种情况下，它会因为模型从未看到过这个词而导致两个类的φ变为零，以至于无法进行预测。

这时我们则需要另一个解决方案，其名为**拉普拉斯平滑**，它将每个参数设置为：

![](media/image27.png)

其中k是类的数量。 在实际操作中，拉普拉斯平滑并没有太大的区别，因为我们的模型中通常包含了所有的单词，但有一个备用计划总是极好的！😊
